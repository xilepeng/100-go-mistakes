1. [#48: panic](#48-panic)
2. [#49：搞不清何时需要包装错误](#49搞不清何时需要包装错误)
3. [#50: 不准确的错误类型检查](#50-不准确的错误类型检查)
4. [#51：错误地检查错误值](#51错误地检查错误值)


总结：
- 如果你使用 Go 1.13 之后版本的 %w 指令和 fmt.Errorf 来包装错误的话，那么需要使用对应的 errors.As 或者 errors.Is 来比较错误的类型或者值，否则检查总会返回 false 。

# #48: panic

>在 Go 代码里，使用 panic 处理错误只应该用于一些比较少见的不可恢复的场景：触发了一个不该发生的代码错误，活着加载必需的依赖时失败了。因此，有一些特殊情况需要我们停止应用程序。在大多数情况下，错误管理应该由函数将适当的错误类型作为最后一个参数返回来完成。


# #49：搞不清何时需要包装错误

>错误包装使用场景：添加上下文信息和标记错误，把一个错误转变为另一个特定的错误。

如果需要标记错误，使用自定义错误类型

```go
func bar() error {
	return barError{}
}
// 用 BarError 包装错误
type BarError struct {
	Err error
}

func listing2() error {
	err := bar()
	if err != nil {
		return BarError{Err: err} // 不直接返回 err,而是用 BarError 包装错误
	}
	// ...
	return nil
}
```

添加上下文信息

```go
    if err != nil {
		return fmt.Errorf("bar failed: %w", err) // 添加上下文信息，可获取原始错误
	}

	if err != nil {
		return fmt.Errorf("bar failed: %v", err) // 添加上下文信息，不可获取原始错误
	}
```


# #50: 不准确的错误类型检查

如果你使用 Go 1.13 之后版本的 %w 指令和 fmt.Errorf 来包装错误的话，那么需要使用对应的 errors.As 或者 errors.Is 来比较错误的类型或者值，否则检查总会返回 false 。

errors.As 判断错误类型是否相同

> errors.As 方法来检查被包装的错误是否是属于某种类型的错误。errors.As 递归地解开一个错误，如果包装链中的一个错误符合预期的类型，则返回 true。



# #51：错误地检查错误值

errors.Is 判断是不是同一错误

> errors.Is 方法检查错误值，使用 errors.Is 代替 == 操作符的好处是：即使错误使用 %w 指令包装，我们依然可以进行错误比较。总之，我们使用 fmt.Errorf 和 %w 指令来包装错误，并且应该使用 errors.Is 来与特定错误进行比较，而不是使用 ==。即使哨兵错误被额外包装了，errors.Is 也可以递归地解包错误，并在包装的错误链上与给定的错误值进行比较。

```go
var ErrFoo = errors.New("foo")
```
哨兵错误指的是全局定义的错误，都是以 Err 开头的，然后加具体错误类型，一个哨兵错误表示一个导出的错误。

标准库哨兵错误例子：
- sql.ErrNoRows 没有查询到任何记录时返回的错误
- io.EOF 没有更多输入了，io.Reader 就会返回该错误。

哨兵错误表达一个调用方有预期、可检测的错误。
- 可预期的错误应该被定义为哨兵错误（错误值），类似： `var ErrFoo = errors.New("foo")。
- 非预期的错误可以被设计为错误类型，类似：type BarError struct{},并且 BarError 实现 error 接口。

