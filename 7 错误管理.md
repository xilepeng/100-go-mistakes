1. [#48: panic](#48-panic)
2. [#49：搞不清何时需要包装错误](#49搞不清何时需要包装错误)
3. [#50: 不准确的错误类型检查](#50-不准确的错误类型检查)
4. [#51：错误地检查错误值](#51错误地检查错误值)
5. [#52：处理同一个错误两次](#52处理同一个错误两次)
6. [#53：忽略错误](#53忽略错误)
7. [#54：忽略 defer 语句返回的错误](#54忽略-defer-语句返回的错误)


总结：
- 在 Go 代码里，使用 panic 处理错误是一种选择，但是只应该用于一些比较少见的不可恢复的场景：触发了一个不该发生的代码错误，活着加载必需的依赖时失败了。因此，有一些特殊情况需要我们停止应用程序。在大多数情况下，错误管理应该由函数将适当的错误类型作为最后一个参数返回来完成。

- 包装错误可以标记一个错误，或者提供额外的上下文信息，也可两者兼而有之。

- 如果你使用 Go 1.13 之后版本的 %w 指令和 fmt.Errorf 来包装错误的话，那么需要使用对应的 errors.As 或者 errors.Is 来比较错误的类型或者值，否则检查总会返回 false 。

- 为了传递一个预期的错误，可以使用哨兵错误（注意，哨兵错误是错误值，而不是错误类型）。非预期的错误应该使用特定的错误类型。

- 一个错误只应该被处理一次。记录错误也是错误处理的一种方式，要么记录错误，要么返回错误，而不是两者都做。在很多情况下，包装错误可以让你往原始错误上添加上下文信息并返回错误。

- 不管是在函数调用，还是在 defer 语句里，忽略错误都应该通过空标识符来显式地呈现意图。

- 在很多场景，我们都不应该忽略 defer 语句调用返回的错误。根据上下文，要么直接处理错误，要么暴露给调用方处理。但如果需要忽略错误的话，那就应该明确使用空标识符显式表示意图。

# #48: panic

>在 Go 代码里，使用 panic 处理错误是一种选择，但是只应该用于一些比较少见的不可恢复的场景：触发了一个不该发生的代码错误，活着加载必需的依赖时失败了。因此，有一些特殊情况需要我们停止应用程序。在大多数情况下，错误管理应该由函数将适当的错误类型作为最后一个参数返回来完成。


# #49：搞不清何时需要包装错误

>错误包装使用场景：添加上下文信息和标记错误，把一个错误转变为另一个特定的错误。

如果需要标记错误，使用自定义错误类型

```go
func bar() error {
	return barError{}
}
// 用 BarError 包装错误
type BarError struct {
	Err error
}

func listing2() error {
	err := bar()
	if err != nil {
		return BarError{Err: err} // 不直接返回 err,而是用 BarError 包装错误
	}
	// ...
	return nil
}
```

添加上下文信息

```go
    if err != nil {
		return fmt.Errorf("bar failed: %w", err) // 添加上下文信息，可获取原始错误
	}

	if err != nil {
		return fmt.Errorf("bar failed: %v", err) // 添加上下文信息，不可获取原始错误
	}
```


# #50: 不准确的错误类型检查

如果你使用 Go 1.13 之后版本的 %w 指令和 fmt.Errorf 来包装错误的话，那么需要使用对应的 errors.As 或者 errors.Is 来比较错误的类型或者值，否则检查总会返回 false 。

errors.As 判断错误类型是否相同

> errors.As 方法来检查被包装的错误是否是属于某种类型的错误。errors.As 递归地解开一个错误，如果包装链中的一个错误符合预期的类型，则返回 true。



# #51：错误地检查错误值

errors.Is 判断是不是同一错误

> errors.Is 方法检查错误值，使用 errors.Is 代替 == 操作符的好处是：即使错误使用 %w 指令包装，我们依然可以进行错误比较。总之，我们使用 fmt.Errorf 和 %w 指令来包装错误，并且应该使用 errors.Is 来与特定错误进行比较，而不是使用 ==。即使哨兵错误被额外包装了，errors.Is 也可以递归地解包错误，并在包装的错误链上与给定的错误值进行比较。

```go
var ErrFoo = errors.New("foo")
```
哨兵错误指的是全局定义的错误，都是以 Err 开头的，然后加具体错误类型，一个哨兵错误表示一个导出的错误。

标准库哨兵错误例子：
- sql.ErrNoRows 没有查询到任何记录时返回的错误
- io.EOF 没有更多输入了，io.Reader 就会返回该错误。

哨兵错误表达一个调用方有预期、可检测的错误。
- 可预期的错误应该被定义为哨兵错误（错误值），类似： `var ErrFoo = errors.New("foo")。
- 非预期的错误可以被设计为错误类型，类似：type BarError struct{},并且 BarError 实现 error 接口。


# #52：处理同一个错误两次

一个错误只应该被处理一次。记录错误和返回错误都是错误处理。我们要么记录，要么返回，不要既记录错误又返回错误。

每个错误只被处理一次，这会让代码更简单（避免了记录重复的错误日志消息）。
通过这种方式，可以简化代码且对错误场景有更好的理解。错误包装是传递错误并附加上下文信息最方便的方式。



# #53：忽略错误

```go
 _ = notify()
```

# #54：忽略 defer 语句返回的错误

未显式地忽略 ❌
```go
defer rows.Close() 
```

我们至少应该显式地忽略错误
```go
defer func() { _ = rows.Close() }()
```

```go
	defer func() {
		closeErr := rows.Close()
		if err != nil {
			if closeErr != nil {
				log.Printf("failed to close rows: %v", err)
			}
			return
		}
		err = closeErr
	}()
```

>我们至少应该显式地忽略错误，如果不能显式地忽略，那就像上文演示的一样，要么直接记录错误日志，要么返回给调用方处理。

