
1. [#61: 传播部恰当的上下文](#61-传播部恰当的上下文)
2. [#62: 在不知道何时停止的情况下启动 goroutine](#62-在不知道何时停止的情况下启动-goroutine)
3. [#63: 没有小心处理 groutine 和循环变量](#63-没有小心处理-groutine-和循环变量)
4. [#64: 使用 select 和 channel 来期待确定性行为](#64-使用-select-和-channel-来期待确定性行为)
5. [#65: 没有使用通知 channel](#65-没有使用通知-channel)
6. [#66: 没有使用 nil channel](#66-没有使用-nil-channel)
7. [#67: 对 channel 缓冲去大小感到困惑](#67-对-channel-缓冲去大小感到困惑)
8. [#68: 忘记字符串格式化可能产生的副作用](#68-忘记字符串格式化可能产生的副作用)
9. [#69: 使用 append 函数创造了数据竞争](#69-使用-append-函数创造了数据竞争)
10. [#70：对切片和 map 不准确地使用互斥锁](#70对切片和-map-不准确地使用互斥锁)
11. [#71: 错误使用 sync.WaitGroup](#71-错误使用-syncwaitgroup)
12. [#72：忘记了 sync.Cond](#72忘记了-synccond)
13. [#73: 没有使用 errgroup](#73-没有使用-errgroup)
14. [#74：复制 sync 类型](#74复制-sync-类型)


- 要准确使用 sync.WaitGroup, 请在 goroutine 之前调用 Add 方法。


# #61: 传播部恰当的上下文

```go
package main

import (
	"context"
	"net/http"
	"time"
)

func handler1(w http.ResponseWriter, r *http.Request) {
	response, err := doSomeTask(r.Context(), r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	go func() {
		err := publish(r.Context(), response)
		// Do something with err
		_ = err
	}()

	writeResponse(response)
}

func handler2(w http.ResponseWriter, r *http.Request) {
	response, err := doSomeTask(r.Context(), r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	// 异步处理发布操作，如果上下文被取消，发布消息的操作可以被中断
	// 不管写回 HTTP 响应需要多长时间，我们都可以调用 publish
	go func() {
		err := publish(context.Background(), response) // 使用空上下文而不是 HTTP 请求上下文
		// Do something with err
		_ = err
	}()

	writeResponse(response)
}

// 一旦我们返回响应，上下文就会被取消，异步操作也可能会被意外停止。
// 最佳实践：创建自定义上下文，不携带取消信号
// 传递给 publish 的上下文永远不会过期或被取消，但它将携带父上下文的值
func handler3(w http.ResponseWriter, r *http.Request) {
	response, err := doSomeTask(r.Context(), r)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	// 调用 publish 并分离取消信号
	go func() {
		// 在 HTTP 上下文之上使用分离
		err := publish(detach{ctx: r.Context()}, response)
		// Do something with err
		_ = err
	}()

	writeResponse(response)
}

// 创建自定义上下文，不携带取消信号
type detach struct {
	ctx context.Context
}

func (d detach) Deadline() (time.Time, bool) {
	return time.Time{}, false
}

func (d detach) Done() <-chan struct{} {
	return nil
}

func (d detach) Err() error {
	return nil
}

func (d detach) Value(key any) any {
	return d.ctx.Value(key)
}

func doSomeTask(context.Context, *http.Request) (string, error) {
	return "", nil
}

func publish(context.Context, string) error {
	return nil
}

func writeResponse(string) {}
```


# #62: 在不知道何时停止的情况下启动 goroutine

```go
package main

func main() {
	newWatcher()
	// Run the application
}

func newWatcher() {
	w := watcher{}
	go w.watch()
}

type watcher struct { /* Some resources */
}

func (w watcher) watch() {}
```
当主 goroutine 退出时，应用程序会停止，watcher 创建的资源不会优雅关闭。怎么防止这种情况发生？

1. 向 newWatcher 传递一个上下文，该上下文将在 main 返回时被取消：
```go
package main
import "context"
func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	newWatcher(ctx)
	// Run the application
}

func newWatcher(ctx context.Context) {
	w := watcher{}
	go w.watch(ctx)
}

type watcher struct { /* Some resources */
}
func (w watcher) watch(context.Context) {}
```
我们能保证监视程序有时间关闭操作吗？绝对无法保证——这就是一个设计缺陷。
问题在于我们是使用信号来传达一个 goroutine 必须停止的。在资源关闭之前，我们没有阻塞父 goroutine。

给 watcher 创建一个 close 方法，延迟调用 close 方法，
而不是通知 watcher 是时候关闭它的资源了，使用defer 保证资源在应用程序退出之前关闭。
```go
package main

func main() {
	w := newWatcher()
	defer w.close()

	// Run the application
}

func newWatcher() watcher {
	w := watcher{}
	go w.watch()
	return w
}

type watcher struct { /* Some resources */
}

func (w watcher) watch() {}

func (w watcher) close() {
	// Close the resources
}
```

# #63: 没有小心处理 groutine 和循环变量

**Goroutines**
在Go语言中使用go关键字后跟函数名称或定义完整的匿名函数即可开启一个新的Goroutine，使用go关键字调用函数后会立即返回，该函数在后
台作为Goroutine运行，程序的其余部分继续执行，但是，如上所述，您无法控制您的Goroutine的执行顺序，因为这取决于
操作系统的调度程序，Go调度程序以及操作系统的负载。

匿名函数中的循环变量快照问题。下面这个单独的变量 i 是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了f并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。
显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个f。

```go
package main

import (
	"fmt"
	"time"
)

func listing0() {
	for i := 0; i < 3; i++ {
		fmt.Printf("&i=%p\n", &i)
	}
}

// go 1.22 后，i 的地址是变化的
// i0 i1 i2,超出作用域自动回收
//&i=0x14000182020
//&i=0x14000182040
//&i=0x14000182048

// 闭包绑定了一个变量，导致变量超出了它的作用域
func listing1() {
	s := []int{1, 2, 3}
	for _, v_copy := range s {
		go func() { // 闭包是一个函数值，它不会捕获 goroutine 创建时的值，而是所有 goroutine 都引用完全相同的变量i，
			fmt.Print(v_copy) // 因此，自 goroutine 启动以来 i 的地址可能已被修改
		}()
	}
}

// 不以特定顺序打印 123（因为不能保证创建的第一个 goroutine 会首先执行完成）
// 312 132 123 213

func listing2() {
	s := []int{1, 2, 3}
	for _, v_copy := range s {
		val := v_copy // 为每次迭代创建一个新变量
		go func() {
			fmt.Print(val)
		}()
	}
}

// 不以特定顺序打印 123（因为不能保证创建的第一个 goroutine 会首先执行完成）
// 312 132 123 213

func listing3() {
	s := []int{1, 2, 3}
	for _, v_copy := range s {
		go func(val int) { // 执行带参数函数
			fmt.Print(val)
		}(v_copy) // 调用函数并传递 i 的当前值
	}
}

// 不以特定顺序打印 123（因为不能保证创建的第一个 goroutine 会首先执行完成）
// 312 132 123 213
func main() {
	//listing0()
	//listing1() // 312 132 123 213
	//listing2() // 312 132 123 213
	listing3()
	time.Sleep(1 * time.Second)
}
```


# #64: 使用 select 和 channel 来期待确定性行为

select 的 case 语句是随机选择的：防止可能的饥饿
为了避免发生这种情况，
- 在单个生产者 goroutine 的情况下，我们可以使用非缓冲 channel 或单个 channel
- 在多个生产者 goroutine 的情况下，我们内部选择和default 来处理优先级

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	messageCh := make(chan int, 10)
	disconnectCh := make(chan struct{})

	//go listing1(messageCh, disconnectCh)
	go listing2(messageCh, disconnectCh)

	for i := 0; i < 10; i++ {
		messageCh <- i
	}
	disconnectCh <- struct{}{}
	time.Sleep(10 * time.Millisecond)
}

// switch 的 case 语句是依赖顺序的
// select 的 case 语句是随机选择的：防止可能的饥饿
func listing1(messageCh <-chan int, disconnectCh chan struct{}) {
	for {
		select {
		case v := <-messageCh:
			fmt.Println(v)
		case <-disconnectCh:
			fmt.Println("disconnection, return")
			return
		}
	}
}

// case 语句随机执行

// 如果想在连接中断导致返回前接收所有消息，解决方案：
// 从 messageCh 或 disconectCh 接收
// 如果收到断开链接消息
//    读取 messageCh 中的所有现有消息
//    然后返回
func listing2(messageCh <-chan int, disconnectCh chan struct{}) {
	for {
		select {
		case v := <-messageCh:
			fmt.Println(v) // 0
		case <-disconnectCh:
			for {
				select {
				case v := <-messageCh: // 读取剩余的消息
					fmt.Println(v) // 123456789
				default: // 仅当其他情况都不匹配时，才会选择在 select 语句中使用 default
					fmt.Println("disconnection, return")
					return // 意味着只有收到 messageCh 中的所有剩余消息后才会返回
				}
			}
		}
	}
}

// 0123456789
// disconnection, return

```
# #65: 没有使用通知 channel 
channel 是一种通过信号在 goroutine 之间进行通信的机制。信号可以有数据也可以没数据

如果只预期 true 信息，我们需要一个没有数据的 channel。处理它的惯用方式是使用空结构体的 channel: `chan struct{}`

在 Go 中，空结构体是没有任何字段的结构体。无论什么架构，都占0字节存储空间。
空结构是传达无意义数据的事实标准。
```go
	var s struct{}
	var i interface{}
	fmt.Println(unsafe.Sizeof(s)) // 0
	fmt.Println(unsafe.Sizeof(i)) // 16   32位架构占用8字节
```
如果我们想创建一个 channel 来发送没有数据的通知，那么在 Go 中执行此操作的适当方式是 `chan struct{}`

没有数据的 channel 应该用 `chan struct{}`类型表示。它向接受者阐明，不应该预期消息内容有任何意义——只是能收到消息。此类 channel 被称为
**通知 channel**
```go
var chan struct{} // 通知 channel 
```

# #66: 没有使用 nil channel 

```go
package main

import (
	"fmt"
	"time"
)

func merge1(ch1, ch2 <-chan int) <-chan int {
	ch := make(chan int, 1)

	go func() {
		for v := range ch1 { // 从 ch1 接收，然后从 ch2 接收，ch1 关闭之前不会收到 ch2 的消息
			ch <- v
		}
		for v := range ch2 {
			ch <- v
		}
		close(ch)
	}()

	return ch
}

// <-chan 只读通道 chan<- 只写通道
func merge2(ch1, ch2 <-chan int) <-chan int {
	ch := make(chan int, 1)

	go func() {
		for {
			select { // 同时接收 ch1 ch2 的消息
			case v := <-ch1:
				ch <- v // 问题：如果ch1 关闭就不能工作了
			case v := <-ch2:
				ch <- v
			}
		}
		close(ch) // 问题：不可访问
	}()

	return ch
}

func merge3(ch1, ch2 <-chan int) <-chan int {
	ch := make(chan int, 1)
	ch1Closed := false
	ch2Closed := false

	go func() {
		for { // 问题：当两个 channel 之一被关闭时，for 循环将持续循环知道 channel 有数据，
			// 这意味着即使在另一个 channel 中没有收到新消息，for 循环也会继续循环
			// 浪费 CPU 周期，必须避免这种情况发生
			select {
			case v, open := <-ch1:
				if !open { // ch1 被关闭时处理
					ch1Closed = true
					break
				}
				ch <- v
			case v, open := <-ch2:
				if !open { // // ch1 被关闭时处理
					ch2Closed = true
					break
				}
				ch <- v
			}

			if ch1Closed && ch2Closed { // ch1 ch2 都被关闭，则关闭ch并返回
				close(ch)
				return
			}
		}
	}()

	return ch
}

// 从 nil channel 接收消息将永远阻塞，在 channel 关闭后将此 channel 分配给 nil
// 可以使用 nil channel 实现一个优雅的状态机，该状态机降从 select 语句中删除一个案例
func merge4(ch1, ch2 <-chan int) <-chan int {
	ch := make(chan int, 1)

	go func() {
		for ch1 != nil || ch2 != nil { // 如果至少一个 channel 不是 nil 则继续
			select {
			case v, open := <-ch1:
				if !open {
					ch1 = nil // 一旦 ch1 被关闭，将其赋值为 nil channel
					break
				}
				ch <- v
			case v, open := <-ch2:
				if !open {
					ch2 = nil // 一旦 ch2 被关闭，将其赋值为 nil channel
					break
				}
				ch <- v
			}
		}
		close(ch)
	}()

	return ch
}

func PrintChan(ch <-chan int) {
	for v := range ch {
		fmt.Println(v)
	}
}
func main() {
	ch1 := make(chan int)
	ch2 := make(chan int)

	go func() {
		//time.Sleep(1 * time.Second)
		ch1 <- 1
		close(ch1)
	}()

	go func() {
		time.Sleep(1 * time.Second)
		ch2 <- 2
		close(ch2)
	}()
	ch := merge1(ch1, ch2)
	//ch := merge2(ch1, ch2)
	//ch := merge3(ch1, ch2)
	//ch := merge4(ch1, ch2)
	PrintChan(ch)
}

```
# #67: 对 channel 缓冲去大小感到困惑

如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。

-  非缓冲 channel (同步 channel，可实现同步),发送者将阻塞，直到接受者从 channel 接收到数据
- 缓冲 channel 已满，它将阻塞，直到接受者 goroutine 收到消息,无法解除阻塞的通道将死锁

- 从已关闭的通道中读取数据时返回零值，通过检查通道是否关闭，我们可以避免零值干扰。
- 向已关闭的通道中写入数据，会引发 panic 并导致程序崩溃



# #68: 忘记字符串格式化可能产生的副作用



# #69: 使用 append 函数创造了数据竞争

# #70：对切片和 map 不准确地使用互斥锁






# #71: 错误使用 sync.WaitGroup

> 当使用 sync.WaitGroup 时，Add 操作必须在父 goroutine 中启动 goroutine 之前完成，而 Done 操作必须在 goroutine 内完成。

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

// 请在 goroutine 之前调用 Add 方法
func listing1() {
	wg := sync.WaitGroup{}
	var v uint64
	// Add 应在父 goroutine 中启动，并在 goroutine 启动前完成
	// 创建3个goroutine
	for i := 0; i < 3; i++ {
		go func() {
			wg.Add(1) // 不在父 goroutine 中调用，不能保证我们已经想等待组指示我们要在调用 wg.Wait() 之前等待3个 goroutine
			atomic.AddUint64(&v, 1)
			wg.Done()
		}()
	}

	wg.Wait()
	fmt.Println(v)
}

func listing2() {
	wg := sync.WaitGroup{}
	var v uint64

	wg.Add(3)
	for i := 0; i < 3; i++ {
		go func() {
			atomic.AddUint64(&v, 1)
			wg.Done()
		}()
	}

	wg.Wait()
	fmt.Println(v)
}

func listing3() {
	wg := sync.WaitGroup{}
	var v uint64

	for i := 0; i < 3; i++ {
		wg.Add(1)
		go func() {
			atomic.AddUint64(&v, 1)
			wg.Done()
		}()
	}

	wg.Wait()
	fmt.Println(v)
}

func main() {
	listing1() // 0 没有同步，得到一个不确定的值
	listing2() // 3
	listing3() // 3
}
```




锁住共享资源
Go 语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。如果需要顺序访问一个
整型变量或者一段代码，atomic和 sync包里的函数提供了很好的解决方案。



互斥锁（mutex）用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以
执行这个临界区代码。





# #72：忘记了 sync.Cond

# #73: 没有使用 errgroup

# #74：复制 sync 类型

