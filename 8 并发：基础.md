1. [#55: 混淆并发和并行](#55-混淆并发和并行)
2. [#56: 认为并发总是更快](#56-认为并发总是更快)



# #55: 混淆并发和并行


# #56: 认为并发总是更快

src/runtime/proc.go
```go
// Goroutine scheduler
// The scheduler's job is to distribute ready-to-run goroutines over worker threads.
//
// The main concepts are:
// G - goroutine.
// M - worker thread, or machine.
// P - processor, a resource that is required to execute Go code.
//     M must have an associated P to execute Go code, however it can be
//     blocked or in a syscall w/o an associated P.
```

**GO 调度**

线程是操作系统可以执行的最小单元。如果一个进程想要同时执行多个动作，它可以启动多个线程。这些线程可以是：

- 并发——两个或者更多线程可以在同一时间段内启动、运行和完成。
- 并行——同一个任务可以同时执行多次

操作系统负责优化调度线程的那些进程：

- 所有的线程都可以消费 CPU 周期，不会饥饿太久。
- 工作负载尽可能地被均匀分布在不同的 CPU 核上。


- G——Goroutine
- M——操作系统线程（代表 machine）
- P——CPU 核（代表 processor）

每个操作系统线程（M）由操作系统调度器指派给 CPU 核（P），每个 goroutine(G)都会在 M 上运行。
GOMAXPROCS 变量定义了负责同时执行用户级代码的 M 的最大数量。但是如果一个线程在系统调用中被阻塞，调度器可以启动更多的 M。

goroutine 的生命周期比操作系统线性的生命周期更简单。它可以处于下面的状态之一。
- executing——goroutine 被调度在 M 上，并正在执行它的指令。
- running——goroutine 正等待进入 executing 状态。
- waiting——goroutine 暂停并等待某事完成。



**Go 运行时如何实现调度？**

每执行 61 次，Go 调度器会检查全局队列中是否有可用的 Goroutine，如果不可用，它检查它的本地队列。同时，如果全局队列和本地队列都为空，Go 调度器从其他本地对了中挑选一个 goroutine，调度中的这个原则被称为工作窃取(work stealing),它允许未充分利用的 P 主动去寻找另一些 P 的 goroutine，窃取一些 goroutine。


伪代码
```go
runtime.schedule(){
	// 只有 1/61 的次数，来检查全局可运行的队列，去选择一个 G。
	// 如没找到，就检查本地队列。
	// 如果没找到，
	//    尝试从其他 P 的本地队列里窃取一个。
	//    如果还没找到，再检查全局可运行的队列。
	//    如果还没找到，检查处理网络的 goroutine。
}
```

从 Go 1.14 开始，Go 调度器变成了抢占式地：当一个 goroutine 连续运行超过特定的时间(10毫秒)时，它会被标记成科抢占的，并且可以通过上下文切换被另一个 goroutine 替换。这样就强制长时间运行的任务分享一部分 CPU 时间。

