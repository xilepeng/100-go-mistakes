1. [42：不知道使用什么类型的接收器](#42不知道使用什么类型的接收器)
2. [43： 不要使用命名的结果参数](#43-不要使用命名的结果参数)
3. [44：使用命名的结果参数的意外副作用](#44使用命名的结果参数的意外副作用)
4. [45：返回一个 nil 接收器](#45返回一个-nil-接收器)
5. [46：使用文件名作为函数输入](#46使用文件名作为函数输入)
6. [47：忽略 defer 语句参数和接收器的计算](#47忽略-defer-语句参数和接收器的计算)

总结：

- 对于使用值接收器还是指针接收器，当存在疑问时，请使用指针接收器。
- 当返回一个接口类型时，要小心返回的不是空指针，而是一个显示 nil 值 

## 42：不知道使用什么类型的接收器

1. 对于值接收器，Go 语言通过对值生成一份拷贝来传递给方法。对对象的任何变更都在方法内部进行，原始对象保持不变。

2. 在使用指针接收器时，Go 语言将对象的地址传递给方法。本质上，它仍然是一个拷贝，但是只会复制一个指针，而不是对象本身（在 Go 语言中不存在传递引用）。任何对接收器的改动都会对原始对象生效。


*接收器必须是指针* 

- 当方法需要修改接收器时。当接收器是一个切片，并且这个方法需要追加元素时，这个规则同样适用：

```go
type slice []int

func (s *slice) add (element int) {
    *s = append(*s, element)
}
```

- 当方法接收器包含一个不能被复制的成员时。例如，sync 包的类型部分（#74讨论）

*接收器应该是指针* 

- 当接收器是一个很大的对象时（防止复制造成开销过大）。

*接收器必须是值*

- 当我们强制接收器不可修改时。
- 当接收器是一个 map 字典类型、函数或者 channel 时。否则，编译会产生错误。

*接收器应该是值*

- 当接收器是不需要被变更的切片时。
- 当接收器是一个由基础类型构成的小数组或者结构体，并且不包含可变的成员时，像 time.Time 。
- 当接收器是像 int、float64 或 string 这样的基础类型时。

应避免使用混合接收器类型


总结：在默认情况下，我们可以选择使用值接收器，除非有充分的理由不这样做。对于有质疑的场景，可以使用指针接收器。






## 43： 不要使用命名的结果参数

在大多数场景中，在定义接口的场景使用命名的结果参数可以提升代码的可读性，而不会产生任何副作用。
如果两个参数有相同类型，命名的结果参数也能增加可读性。 因此，当有明显好处时，可以谨慎使用命名结果参数。





## 44：使用命名的结果参数的意外副作用

不能混合使用独立 return 语句与带返回参数的 return 语句





## 45：返回一个 nil 接收器

在 Go 语言中，是允许有一个 nil 接收器的，而且由一个 nil 指针转换的接口并不是一个 nil 接口。出于这个原因，当要返回一个接口时，应该直接返回一个 nil 值而不是一个 nil 指针。


在 Go 语言中，一个接收器指针一定是 nil

```go
type Foo struct{}

func (foo *Foo) Bar() string {
	return "bar"
}

func main() {
	var foo *Foo
	fmt.Println("foo=",foo) // nil
	fmt.Println("foo.Bar()=",foo.Bar()) // bar
}
```

foo 被初始化位指针的0值：nil。 编译运行会打印出 bar。 一个 nil 指针是一个有效的接收器。


方法是函数的语法糖，函数的第一个参数是接收器，因此我们看到的 Bar 方法和以下函数类似：

```go
func Bar(foo *Foo) string {
	return "bar"
}
```



```go
func (c Customer) Validate1() error {
	var m *MultiError

	if c.Age < 0 {
		m = &MultiError{}
		m.Add(errors.New("age is negative"))
	}
	if c.Name == "" {
		if m == nil {
			m = &MultiError{}
		}
		m.Add(errors.New("name is nil"))
	}

	return m
}
```
m被初始化为指针的0值：nil。然而，如果所有检查都有效，那么提供给 return 语句的参数不是直接的 nil, 而是一个 nil 指针。因为一个 nil 指针是一个有效的接收器，将结果转换为接口不会产生 nil 空值。换句话说， Validate 的调用者将总是获得一个非 nil 错误。



如何修复？ 只有当不是 nil 的时候返回 m 


```go
func (c Customer) Validate2() error {
	var m *MultiError

	if c.Age < 0 {
		m = &MultiError{}
		m.Add(errors.New("age is negative"))
	}
	if c.Name == "" {
		if m == nil {
			m = &MultiError{}
		}

		m.Add(errors.New("name is nil"))
	}

	if m != nil {
		return m // 只有当至少有一个 error 时返回 m
	}
	return nil // 否则返回 nil 
}
```

*因此，当输入有效的 Customer时，我们会返回一个 nil 接口，而不是由 nil 接收器转换的一个非 nil 接口。*


## 46：使用文件名作为函数输入

在大多数情况下，使用文件名作为函数参数去读取文件，会被视为代码异味（但一些特定的函数除外，例如 os.Open）可使用 io.Reader 接口抽象数据源，不管输入是文件、字符串、HTTP 请求，还是 gRPC请求，这个实现都能被复用，而且很容易被测试。


## 47：忽略 defer 语句参数和接收器的计算

在函数或方法上调用defer,调用的参数会被立即计算。如果想修改已经提供给defer 语句的参数，可以使用指针或闭包。

如果接收器是值，调用defer后，接收器的潜在变化是不可见的
```go
func main() {
	s := Struct{id: "foo"}
	defer s.print() //s会被立即计算
	s.id = "bar"    //更新s.id（不可见）
}

type Struct struct {
	id string
}

func (s Struct) print() {
	fmt.Println(s.id) //结果是foo
}
```

如果接收器是指针，调用defer后，接收器的潜在变化是可见的
```go
func main() {
	s := &Struct{id: "foo"}
	defer s.print() // s会被立即计算
	s.id = "bar"    // 更新s.id（可见）
}

type Struct struct {
	id string
}

func (s *Struct) print() {
	fmt.Println(s.id)// 结果是 bar
}
```

