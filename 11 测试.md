1. [#89: 写出不准确的基准测试](#89-写出不准确的基准测试)


# #89: 写出不准确的基准测试

main_test.go
```go
package main

import (
	"sync/atomic"
	"testing"
)

func BenchmarkAtomicStoreInt32(b *testing.B) {
	var v int32
	for i := 0; i < b.N; i++ {
		atomic.StoreInt32(&v, 1)
	}
}

func BenchmarkAtomicStoreInt64(b *testing.B) {
	var v int64
	for i := 0; i < b.N; i++ {
		atomic.StoreInt64(&v, 1)
	}
}

```
-benchmem 展示内存
-run=none 不执行单元测试
```bash
➜ go test -benchmem -run=none -bench=. -count=10 | tee stats.txt

BenchmarkAtomicStoreInt32-10            1000000000               0.4812 ns/op
BenchmarkAtomicStoreInt32-10            1000000000               0.4807 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4810 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4846 ns/op

➜ benchstat stats.txt
goos: darwin
goarch: arm64
pkg: github.com/xilepeng/100-go-mistakes/11-testing/89-benchmark/wrong-assumptions
cpu: Apple M4
                    │  stats.txt   │
                    │    sec/op    │
AtomicStoreInt32-10   0.4824n ± 1%
AtomicStoreInt64-10   0.4841n ± 1%
geomean               0.4832n

```

**未重置或暂停计时器**

在执行耗时操作前停止基准测试计时器，执行完后恢复计时器。

```go
package timer

import "testing"

func BenchmarkFoo1(b *testing.B) {
	expensiveSetup()
	b.ResetTimer() // 重置基准测试计时器
	for i := 0; i < b.N; i++ {
		functionUnderTest()
	}
}

func BenchmarkFoo2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		b.StopTimer()// 停止基准测试计时器
		expensiveSetup()
		b.StartTimer()// 恢复基准测试计时器
		functionUnderTest()
	}
}

func functionUnderTest() {
}

func expensiveSetup() {
}
```



**未注意编译器的优化**

为了避免编译器优化欺骗基准测试结果，最佳实践：
1. 在每次循环迭代期间，将结果赋值给一个局部变量。
2. 将最新的结果赋值给全局变量。

```go
package main

import "testing"

func BenchmarkPopcnt1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		popcnt(uint64(i))
	}
}

var global uint64

func BenchmarkPopcnt2(b *testing.B) {
	var v uint64
	for i := 0; i < b.N; i++ {
		v = popcnt(uint64(i))
	}
	global = v
}
```
为什么不将 popcnt 调用的结果直接赋值给 global 变量以简化测试呢？
>因为写入全局变量比写入局部变量慢（#95讨论）。因此，我们应该将每次的结果写入一个局部变量，以减少开销。


将被测函数的返回结果赋值给局部变量，然后将最新结果赋值给全局变量。


