1. [#82：未区分测试种类](#82未区分测试种类)
2. [#83：未打开 -race 开关](#83未打开--race-开关)
3. [#89: 写出不准确的基准测试](#89-写出不准确的基准测试)


# #82：未区分测试种类

- 在单个文件上使用 build 标识
- 用环境变量来表示单个测试
- 用于测试运行的速度使用短模式


- 如果在这个包里不带任何选项地执行 `go test -v . `，就会只运行不包含 build 标识的测试文件
- 如果加上 integration 标识，build 标识文件也会被执行 `go test --integration -v . `
```go
//go:build integration
// build 标识：针对单个文件

package db

import (
	"os"
	"testing"
)

func TestInsert1(t *testing.T) {
	// ...
}

// 环境变量
func TestInsert2(t *testing.T) {
	if os.Getenv("INTEGRATION") != "true" {
		t.Skip("skipping integration test")
	}
}
```

```go
// 短模式:针对单个测试，非文件
func TestLongRunning(t *testing.T) {
	if testing.Short() {// 如果开启了短模式，则跳过长耗时测试
		t.Skip("skipping long-running test")
	}
}
// go test -shot -v .
```


# #83：未打开 -race 开关

```bash
go test -race -v .

go run -race -v .

go build -race -v .
```

开启竞态检测器后的开销：
- 内存使用量增加 5~10 倍
- 执行时间增加 2~20 倍

```go
package main

func race() {
	i := 0

	go func() {
		i++
	}()

	go func() {
		i++
	}()
}

func main() {
	for i := 0; i < 10;i++{// 增加捕获数据竞争的可能性
	race()
	}
}
```

//go:build !race  避免竞态检测
```go
//go:build !race 
```


# #89: 写出不准确的基准测试

main_test.go
```go
package main

import (
	"sync/atomic"
	"testing"
)

func BenchmarkAtomicStoreInt32(b *testing.B) {
	var v int32
	for i := 0; i < b.N; i++ {
		atomic.StoreInt32(&v, 1)
	}
}

func BenchmarkAtomicStoreInt64(b *testing.B) {
	var v int64
	for i := 0; i < b.N; i++ {
		atomic.StoreInt64(&v, 1)
	}
}

```
-benchmem 展示内存
-run=none 不执行单元测试
```bash
➜ go test -benchmem -run=none -bench=. -count=10 | tee stats.txt

BenchmarkAtomicStoreInt32-10            1000000000               0.4812 ns/op
BenchmarkAtomicStoreInt32-10            1000000000               0.4807 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4810 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4846 ns/op

➜ benchstat stats.txt
goos: darwin
goarch: arm64
pkg: github.com/xilepeng/100-go-mistakes/11-testing/89-benchmark/wrong-assumptions
cpu: Apple M4
                    │  stats.txt   │
                    │    sec/op    │
AtomicStoreInt32-10   0.4824n ± 1%
AtomicStoreInt64-10   0.4841n ± 1%
geomean               0.4832n

```

**未重置或暂停计时器**

在执行耗时操作前停止基准测试计时器，执行完后恢复计时器。

```go
package timer

import "testing"

func BenchmarkFoo1(b *testing.B) {
	expensiveSetup()
	b.ResetTimer() // 重置基准测试计时器
	for i := 0; i < b.N; i++ {
		functionUnderTest()
	}
}

func BenchmarkFoo2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		b.StopTimer()// 停止基准测试计时器
		expensiveSetup()
		b.StartTimer()// 恢复基准测试计时器
		functionUnderTest()
	}
}

func functionUnderTest() {
}

func expensiveSetup() {
}
```



**未注意编译器的优化**

为了避免编译器优化欺骗基准测试结果，最佳实践：
1. 在每次循环迭代期间，将结果赋值给一个局部变量。
2. 将最新的结果赋值给全局变量。

```go
package main

import "testing"

func BenchmarkPopcnt1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		popcnt(uint64(i))
	}
}

var global uint64

func BenchmarkPopcnt2(b *testing.B) {
	var v uint64
	for i := 0; i < b.N; i++ {
		v = popcnt(uint64(i))
	}
	global = v
}
```
为什么不将 popcnt 调用的结果直接赋值给 global 变量以简化测试呢？
>因为写入全局变量比写入局部变量慢（#95讨论）。因此，我们应该将每次的结果写入一个局部变量，以减少开销。


将被测函数的返回结果赋值给局部变量，然后将最新结果赋值给全局变量。


