1. [#synctest：让异步测试不再头疼](#synctest让异步测试不再头疼)
2. [#82：未区分测试种类](#82未区分测试种类)
3. [#83：未打开 -race 开关](#83未打开--race-开关)
4. [#89: 写出不准确的基准测试](#89-写出不准确的基准测试)


# #synctest：让异步测试不再头疼

```go
func TestAsyncOperation(t *testing.T) {
    synctest.Run(func() {
        done := make(chanbool)

        gofunc() {
            time.Sleep(5 * time.Second) // 模拟耗时操作
            done <- true
        }()

        select {
        case <-done:
            t.Log("操作完成")
        case <-time.After(10 * time.Second):
            t.Fatal("操作超时")
        }
    })
}
```
在 synctest.Run 的环境中，这个测试几乎是瞬间完成的，而不需要真的等待 5 秒钟。更重要的是，测试结果是确定性的，不会出现偶发性失败的情况。这个功能在 Go 1.25 中正式释出，成为标准库的一部分。

简单来说，只需要在测试代码外面套一层 synctest.Run，就能把原本慢且不稳定的测试变得又快又可靠。


# #82：未区分测试种类

- 在单个文件上使用 build 标识
- 用环境变量来表示单个测试
- 用于测试运行的速度使用短模式


- 如果在这个包里不带任何选项地执行 `go test -v . `，就会只运行不包含 build 标识的测试文件
- 如果加上 integration 标识，build 标识文件也会被执行 `go test --integration -v . `
```go
//go:build integration
// build 标识：针对单个文件

package db

import (
	"os"
	"testing"
)

func TestInsert1(t *testing.T) {
	// ...
}

// 环境变量
func TestInsert2(t *testing.T) {
	if os.Getenv("INTEGRATION") != "true" {
		t.Skip("skipping integration test")
	}
}
```

```go
// 短模式:针对单个测试，非文件
func TestLongRunning(t *testing.T) {
	if testing.Short() {// 如果开启了短模式，则跳过长耗时测试
		t.Skip("skipping long-running test")
	}
}
// go test -shot -v .
```


# #83：未打开 -race 开关

```bash
go test -race -v .

go run -race -v .

go build -race -v .
```

开启竞态检测器后的开销：
- 内存使用量增加 5~10 倍
- 执行时间增加 2~20 倍

```go
package main

func race() {
	i := 0

	go func() {
		i++
	}()

	go func() {
		i++
	}()
}

func main() {
	for i := 0; i < 10;i++{// 增加捕获数据竞争的可能性
	race()
	}
}
```

//go:build !race  避免竞态检测
```go
//go:build !race 
```


# #89: 写出不准确的基准测试

**B.Loop：基准测试的正确打开方式**


```go
// 新写法:更清晰
func BenchmarkNew(b *testing.B) {
    setup() // 准备工作不会被计时

    for b.Loop() {
        doSomething() // 只计算这里的时间
    }
}
```


main_test.go

```go
package main

import (
	"sync/atomic"
	"testing"
)

func BenchmarkAtomicStoreInt32(b *testing.B) {
	var v int32
	for i := 0; i < b.N; i++ {
		atomic.StoreInt32(&v, 1)
	}
}

func BenchmarkAtomicStoreInt64(b *testing.B) {
	var v int64
	for i := 0; i < b.N; i++ {
		atomic.StoreInt64(&v, 1)
	}
}

```
-benchmem 展示内存
-run=none 不执行单元测试
```bash
➜ go test -benchmem -run=none -bench=. -count=10 | tee stats.txt

BenchmarkAtomicStoreInt32-10            1000000000               0.4812 ns/op
BenchmarkAtomicStoreInt32-10            1000000000               0.4807 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4810 ns/op
BenchmarkAtomicStoreInt64-10            1000000000               0.4846 ns/op

➜ benchstat stats.txt
goos: darwin
goarch: arm64
pkg: github.com/xilepeng/100-go-mistakes/11-testing/89-benchmark/wrong-assumptions
cpu: Apple M4
                    │  stats.txt   │
                    │    sec/op    │
AtomicStoreInt32-10   0.4824n ± 1%
AtomicStoreInt64-10   0.4841n ± 1%
geomean               0.4832n

```

**未重置或暂停计时器**

在执行耗时操作前停止基准测试计时器，执行完后恢复计时器。

```go
package timer

import "testing"

func BenchmarkFoo1(b *testing.B) {
	expensiveSetup()
	b.ResetTimer() // 重置基准测试计时器
	for i := 0; i < b.N; i++ {
		functionUnderTest()
	}
}

func BenchmarkFoo2(b *testing.B) {
	for i := 0; i < b.N; i++ {
		b.StopTimer()// 停止基准测试计时器
		expensiveSetup()
		b.StartTimer()// 恢复基准测试计时器
		functionUnderTest()
	}
}

func functionUnderTest() {
}

func expensiveSetup() {
}
```



**未注意编译器的优化**

为了避免编译器优化欺骗基准测试结果，最佳实践：
1. 在每次循环迭代期间，将结果赋值给一个局部变量。
2. 将最新的结果赋值给全局变量。

```go
package main

import "testing"

func BenchmarkPopcnt1(b *testing.B) {
	for i := 0; i < b.N; i++ {
		popcnt(uint64(i))
	}
}

var global uint64

func BenchmarkPopcnt2(b *testing.B) {
	var v uint64
	for i := 0; i < b.N; i++ {
		v = popcnt(uint64(i))
	}
	global = v
}
```
为什么不将 popcnt 调用的结果直接赋值给 global 变量以简化测试呢？
>因为写入全局变量比写入局部变量慢（#95讨论）。因此，我们应该将每次的结果写入一个局部变量，以减少开销。


将被测函数的返回结果赋值给局部变量，然后将最新结果赋值给全局变量。



