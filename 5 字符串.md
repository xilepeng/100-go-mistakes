
1. [#36：不理解 rune 的概念](#36不理解-rune-的概念)
2. [#37：字符串迭代不准确](#37字符串迭代不准确)
3. [#38：乱用 trim 函数](#38乱用-trim-函数)
4. [#39：缺乏优化的字符串连接](#39缺乏优化的字符串连接)
5. [#40：无用的字符串转换](#40无用的字符串转换)
6. [#41：子字符串和内存泄露](#41子字符串和内存泄露)


总结：

- rune 对应于 Unicode 代码位的概念，由多个字节组成
- 使用 range 操作付对字符串进行迭代，通过索引对 rune 进行迭代，对应于 rune 字节序列的起始索引。要访问特定的 rune 索引，请将字符串转换为索引 `runes := []rune{s}`
- strings.TrimRight/strings.TrimLeft 删除给定集合中包含的所有尾随前导rune, 而 strings.TrimSuffix/strings.TrimPrefix 返回不包含给定后缀前缀的字符串
- 连接字符串列表应该用 strings.Builder 完成，以防止每次迭代期间分配新字符串
- bytes 包提供的操作与 strings 包相同，但它可避免额外的字节/字符串转换
- 使用复制而不是字符串可以防止内存泄露，因为子字符串操作返回的字符串将有相同的底层字节数组


# #36：不理解 rune 的概念

len() 返回字节数

``` go
func main() {
	s := "hello"
	fmt.Println("字节数=",len(s)) // 字节数 = 5

	s = "汉"
	fmt.Println(len(s)) // "汉"这个字符使用3字节

	s = string([]byte{0xE6, 0xB1, 0x89})
	fmt.Printf("%s\n", s) // 汉
}
```

- Go 的源代码使用 UTF-8 编码，因此，所有字符串字面量都是 UTF-8 编码；
- rune 对应于 Unicode 代码位的概念，表示单个值表示的项，并且它可以由多个字节组成；
- 使用 UTF-8，一个 Unicode 代码位可以编码成 1 到 4 字节；
- 在 Go 中对字符串使用 len 将返回字节数，而不是 rune 数量。



# #37：字符串迭代不准确

len 返回字符串中的字节数，而不是 rune 数

访问特点 rune 的可能优化：
如果字符串由单字节 rune 组成，则可以进行优化 (A~Z,a~z),通过直接使用 s[i] 访问字节的方式，我们可以访问第 i 个 rune,而无须将整个字符串转换为 rune 切片

总结：如果想带带字符串的 rune, 可以直接在字符串上使用 range 循环，但索引对应的不是 rune 索引，而是 rune 的字节序列的起始索引。

```go
	s := "hêllo"       // 5 个rune
	for i := range s { // 迭代 rune 的每个起始索引，不会迭代每个 rune
		fmt.Printf("rune 的每个起始索引 %d: %c\n", i, s[i])
	}
	fmt.Printf("len 返回字符串中的字节数，而不是 rune 数,ê不是单个字节编码的，它需要2个字节，所以len=%d\n", len(s))

	for i, r := range s { // 返回 rune 的起始索引和 rune 本身
		fmt.Printf("rune 的起始索引和 rune 本身 %d: %c\n", i, r)
	}

	// 如果想访问字符串的第i个 rune
	runes := []rune(s)        //·将字符串转换为 rune 切片
	for i, r := range runes { // 迭代 rune 索引和 rune 本身
		fmt.Printf("迭代 rune 索引和 rune 本身 %d: %c\n", i, r)
	}

	s2 := "hello"
	fmt.Printf("%c\n", rune(s2[4])) // 0

// rune 的每个起始索引 0: h
// rune 的每个起始索引 1: Ã
// rune 的每个起始索引 3: l
// rune 的每个起始索引 4: l
// rune 的每个起始索引 5: o
// len 返回字符串中的字节数，而不是 rune 数,ê不是单个字节编码的，它需要2个字节，所以len=6

// rune 的起始索引和 rune 本身 0: h
// rune 的起始索引和 rune 本身 1: ê
// rune 的起始索引和 rune 本身 3: l
// rune 的起始索引和 rune 本身 4: l
// rune 的起始索引和 rune 本身 5: o

// 迭代 rune 索引和 rune 本身 0: h
// 迭代 rune 索引和 rune 本身 1: ê
// 迭代 rune 索引和 rune 本身 2: l
// 迭代 rune 索引和 rune 本身 3: l
// 迭代 rune 索引和 rune 本身 4: o
// o
```


# #38：乱用 trim 函数

- TrimLeft/RrimRight 删除集合中的前导/尾部rune
- TrimePrifix/TrimSuffix 删除给定的前缀/后缀

```go
    // TrimRight 删除给定集合中包含的所有尾部 rune
	fmt.Println(strings.TrimRight("123oxo", "xo"))  // 123
    
	// TrimSuffix 移除后缀
	fmt.Println(strings.TrimSuffix("123oxo", "xo")) // 123o

    // TrimeLeft 删除集合中包含的所有前导 rune
	fmt.Println(strings.TrimLeft("oxo123", "ox"))   // 123
	// TrimPrefix 删除提供的前导前缀
	fmt.Println(strings.TrimPrefix("oxo123", "ox")) // o123

	// Trim 对字符串同时应用 TrimLeft 和 TrimRight, 删除集合中包含的所有前导rune 和尾部rune
	fmt.Println(strings.Trim("oxo123oxo", "ox")) // 123

```



# #39：缺乏优化的字符串连接

+= 将字符串连接起来，由于字符串的“不变性”, 每次迭代在内存中重新分配一个新字符串，这会显著影响函数性能。

从性能方面考虑，连接5个以上的字符串时，使用strings.Builder 方案会更快。
通过调用 WriteString 方法来构造结果字符串，该方法将vale 的内容附加到其内部缓冲区。

如果预先知道将来字符串的字节数，应该使用 Grow 方法预先分配内部字节切片。


```go
A Builder is used to efficiently build a string using [Builder.Write] methods. It minimizes memory copying. The zero value is ready to use. Do not copy a non-zero Builder.

func (b *strings.Builder) Cap() int
func (b *strings.Builder) Grow(n int)
func (b *strings.Builder) Len() int
func (b *strings.Builder) Reset()
func (b *strings.Builder) String() string
func (b *strings.Builder) Write(p []byte) (int, error)       // 附加单个切片
func (b *strings.Builder) WriteByte(c byte) error            // 附加单个字节
func (b *strings.Builder) WriteRune(r rune) (int, error)     // 附加单个 rune
func (b *strings.Builder) WriteString(s string) (int, error) // 附加一个字符串
```

```go
package main

import (
	"strings"
)

// 连接5个以内的字符串，使用 += 运算符代码可读性更高
func concat1(values []string) string {
	s := ""
	for _, value := range values {
		s += value
	}
	return s
}

func concat2(values []string) string {
	sb := strings.Builder{}
	for _, value := range values {
		_, _ = sb.WriteString(value)
	}
	return sb.String()
}

// 从性能方面考虑，连接5个以上的字符串时，使用strings.Builder 方案会更快。
// 如果预先知道将来字符串的字节数，应该使用 Grow 方法预先分配内部字节切片
func concat3(values []string) string {
	total := 0
	for i := 0; i < len(values); i++ { // 迭代字符串切片以计算总字节数
		total += len(values[i])
	}
	// total= 5
	sb := strings.Builder{}
	sb.Grow(total)
	for _, value := range values {
		_, _ = sb.WriteString(value) // 附加一个字符串
	}
	return sb.String() // 返回结果字符串
}

// v3 版本是迄今为止最高效的：比 v1 快 99%，比 v2 快 78%

func main() {
	s := []string{"hello"} // len(s)= 1

	concat1(s)
	concat2(s)
	concat3(s)
}

```

# #40：无用的字符串转换

在 Go 中，字符串是不可变的。
大多数 I/O 实际上是用 []byte 完成的，使用字符串意味着额外的转换。
首先检查是否可以使用字节而不是字符串来实现整个工作流，并避免额外转换的代价。

bytes 包中 TrimSpace 函数，可以去掉所有前导和尾随的空格。

```go
	b := []byte{'a', 'b', 'c'}
	s := string(b)
	b[1] = 'x'                   // 修改切片元素，字符串不可改变
	fmt.Println("b=", string(b)) // b= axc
	fmt.Println("字符串不变性：s=", s)  // abc

	byte_res := bytes.TrimPrefix(b, []byte{'a'})
	fmt.Println("去掉前缀", string(byte_res)) // xc
```

# #41：子字符串和内存泄露

在Go 中使用子字符串操作时，提供的取件基于字节数，而不是rune数，子字符串操作可能会导致内存泄露，因为生成的子字符串将与初始字符串共享相同底层数组。

防止内存泄露：
- 手动复制字符串
- `strings.Clone`

```go
func main() {
	s1 := "Hello, World!"
	s2 := s1[:5] // 前5个字节创建字符串
	fmt.Println(s2)

	s1 = "Hêllo, World!"
	s2 = string([]rune(s1)[:5]) // 前5个rune创建字符串
	fmt.Println(s2)
}

type store struct{}

func (s store) handleLog1(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}
	uuid := log[:36] // 内存泄露
	s.store(uuid)
	// Do something
	return nil
}

// 因为字符串主要是一个指针，所以调用函数传递字符串不会导致字节的深度复制。
// 复制的字符串仍将引用相同的底层数组。-> 导致内存泄露
func (s store) handleLog2(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}
	uuid := string([]byte(log[:36])) // 深度复制，使内部的字节切片引用新的底层数组，防止内存泄露。
	s.store(uuid)
	// Do something
	return nil
}

// strings.Clone 可返回字符串的新副本
func (s store) handleLog3(log string) error {
	if len(log) < 36 {
		return errors.New("log is not correctly formatted")
	}
	uuid := string(strings.Clone(log[:36])) // 复制到新分配中，以防止内存泄露
	s.store(uuid)
	// Do something
	return nil
}
```
