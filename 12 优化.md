1. [95 不了解栈与堆](#95-不了解栈与堆)
   1. [栈 VS 堆](#栈-vs-堆)
   2. [逃逸分析](#逃逸分析)

**总结：**
> 一般来说，向上分享（sharing up）会逃逸到堆, 向下分享会留在栈上。


# 95 不了解栈与堆

> 一般来说，向上分享（sharing up）会逃逸到堆, 向下分享会留在栈上。

## 栈 VS 堆

- 栈是默认内存：它是一种先进先出（LIFO）的数据结构，用于存储特定 goroutine 的所有局部变量。当一个 goroutine 启动时，它会获得 2KB 的连续内存 作为它的栈空间（这个大小随着时间的推移而变化并且可能再次改变）。然而，这个大小在运行时不是固定的，会根据需要增大或缩小（但它在内存中始终保持连续，保持数据局部性）。

栈是自清洁的；它不需要额外的机制，例如 GC

```go
// 栈
func main() {
	// 创建一个栈帧，变量a,b被分配到这个栈帧所在的栈中。
	// 存储的所有变量都是有效的地址，这意味着它们可以被引用和访问。
	a := 3
	b := 2

	c := sumValue(a, b)
	println(c) //强制在堆上分配
}

//go:noinline
func sumValue(x, y int) int {
	// Go 运行时创建一个新的栈帧作为当前 goroutine 栈的一部分。
	// x、y、z 在当前栈帧中一起被分配
	z := x + y
	return z
}
```

Stack
| main: a=3 b=2 | Valid   |
| ------------- | ------- |
|               | Invalid |

a、b 都被分配到栈上


Stack
| main: a=3 b=2         | Valid   |
| --------------------- | ------- |
| sumValue: x=3 y=2 z=5 | Valid   |
|                       | Invalid |

调用 sumValue 创建一个新的栈帧


Stack
| main: a=3 b=2 c=5 | Valid   |
| ----------------- | ------- |
| y=2 z=5           | Invalid |

sumValue 栈帧被删除并被替换为来自 main 的变量。
（x 已被擦除，而 y 和 z 仍在内存中被分配但无法被访问）


---

Stack
| main: a=3 b=2 c=0xc000038730 | Valid   |
| ---------------------------- | ------- |
| y=2 z=5(0xc000038730)        | Invalid |

> 变量引用了一个不再有效的地址

```go
// 堆
func main() {
	a := 3
	b := 2

	c := sumPtr(a, b)
	println(*c)
}

//go:noinline
func sumPtr(x, y int) *int { // 返回一个指针
	z := x + y
	return &z // 如果函数返回后某个变量被引用，则会在堆上分配该变量。
}

/*
➜  95-heap-stack git:(main) ✗ go build -gcflags "-m=2" main.go
# command-line-arguments
./main.go:11:6: cannot inline sumPtr: marked go:noinline
./main.go:3:6: can inline main with cost 78 as: func() { a := 3; b := 2; c := sumPtr(a, b); println(*c) }
./main.go:12:2: z escapes to heap:
./main.go:12:2:   flow: ~r0 = &z:
./main.go:12:2:     from &z (address-of) at ./main.go:13:9
./main.go:12:2:     from return &z (return) at ./main.go:13:2
./main.go:12:2: moved to heap: z
*/
```

- 堆内存是所有 goroutine 共享内存池。

例如：3个 goroutine G1、G2、 G3 中的每一个都有自己的栈，它们共享同一个堆。

| G1  |  G2   | G3  |
| --- | :---: | --- |
| 栈  |  栈   | 栈  |
|     |  堆   |     |

三个 goroutine 都有自己的栈，但共享堆

> z 变量不能存在于栈中，因此，它逃逸到堆中。如果编译器无法证明函数返回后某个变量未被引用，则会在堆上分配该变量。（如果函数返回后某个变量被引用，则会在堆上分配该变量。）

- 栈是自清洁的，并由单个 goroutine 访问。
- 而堆必须由外部系统清理：GC。堆分配得越多，对 GC 施加的压力就越大。当 GC 运行时，它会使用 25% 的可用 CPU 资源，并且可能会产生毫秒级的 "stop the world" 延迟(应用程序暂停的阶段)


对于 Go 运行时来说，在栈上分配更快，因为它很简单：一个指针引用下一个可用的内存地址。而在堆上分配需要更多的努力才能找到正确的位置，因此需要更多的时间。

>注意：使用指针避免复制不一定更快（现代CPU在复制数据方面非常高效，尤其是在同一缓存行中），当必须共享值时使用指针。

- B/op: 每次操作分配多少字节
- allocs/op: 每次操作对应的分配次数

## 逃逸分析

>逃逸分析是指编译器执行的工作，用以决定一个变量应该分配在栈上还是堆上。

- 当无法在栈上完成分配时，会在堆上完成。
- 如果编译器无法证明函数返回后某个变量未被引用，则会在堆上分配该变量。（如果函数返回后某个变量被引用，则会在堆上分配该变量。）
- 一般来说，向上分享（sharing up）会逃逸到堆, 向下分享会留在栈上。

```go
func main() {
	a := 3
	b := 2
	c := sum(&a, &b)// 向下分享留在栈上
	println(c)
}

//go:noinline
func sum(x, y *int) int {
	return *x + *y
}
```

Stack
| main: a=3(0xc000038718) b=2(0xc000038720) | Valid |
| ----------------------------------------- | ----- |
| sum: x=0xc000038718 y=0xc000038720        | Valid |
|                                           |       |

x、y 变量引用有效的地址,a、b不必逃逸


**以下是变量可以逃逸到堆的其他情况：**

- 全局变量，因为多个 goroutine 可以访问它们。
- 发送到 channel 的指针：

```go
type Foo struct { s string }
ch := make(chan *Foo, 1)
foo := &Foo{ s: "x"}
ch<-foo // 将指针发送到 channel,指针逃逸到堆
```

- 由发送到 channel 的值引用的变量：

```go
type Foo struct { s *string }
ch := make(chan Foo, 1)
s := "x"
bar := Foo{s: &s}
ch<-bar // 因为 s 被Foo 通过 Foo 的地址引用, 所以 s 逃逸到堆
```

- 如果一个局部变量太大而不适合栈。
- 如果局部变量的大小未知。
   > 例如： s := make([]int, 10) 可能不会逃逸到堆中，但 s := make([]int, n) 会逃逸到堆中，因为它的大小是基于一个变量的。
- 如果切片的底层数组使用 append 进行了重新分配。

