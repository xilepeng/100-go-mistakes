1. [95 不了解栈与堆](#95-不了解栈与堆)
   1. [栈 VS 堆](#栈-vs-堆)
   2. [逃逸分析](#逃逸分析)


# 95 不了解栈与堆

## 栈 VS 堆

- 栈是默认内存：它是一种先进先出（LIFO）的数据结构，用于存储特定 goroutine 的所有局部变量。当一个 goroutine 启动时，它会获得 2KB 的连续内存 作为它的栈空间（这个大小随着时间的推移而变化并且可能再次改变）。然而，这个大小在运行时不是固定的，会根据需要增大或缩小（但它在内存中始终保持连续，保持数据局部性）。

栈是自清洁的；它不需要额外的机制，例如 GC

Stack
| main: a=3 b=2 | Valid   |
| ------------- | ------- |
|               | Invalid |

a、b 都被分配到栈上


Stack
| main: a=3 b=2         | Valid   |
| --------------------- | ------- |
| sumValue: x=3 y=2 z=5 | Valid   |
|                       | Invalid |

调用 sumValue 创建一个新的栈帧


Stack
| main: a=3 b=2 c=5 | Valid   |
| ----------------- | ------- |
| y=2 z=5           | Invalid |

sumValue 栈帧被删除并被替换为来自 main 的变量。
（x 已被擦除，而 y 和 z 仍在内存中被分配但无法被访问）


- 堆内存是所有 goroutine 共享内存池。

例如：3个 goroutine G1、G2、 G3 中的每一个都有自己的栈，它们共享同一个堆。

| G1  |  G2   | G3  |
| --- | :---: | --- |
| 栈  |  栈   | 栈  |
|     |  堆   |     |

三个 goroutine 都有自己的栈，但共享堆


- 栈是自清洁的，并由单个 goroutine 访问。
- 而堆必须由外部系统清理：GC。堆分配得越多，对 GC 施加的压力就越大。当 GC 运行时，它会使用 25% 的可用 CPU 资源，并且可能会产生毫秒级的 "stop the world" 延迟(应用程序暂停的阶段)


对于 Go 运行时来说，在栈上分配更快，因为它很简单：一个指针引用下一个可用的内存地址。而在堆上分配需要更多的努力才能找到正确的位置，因此需要更多的时间。

>注意：使用指针避免复制不一定更快（现代CPU在复制数据方面非常高效，尤其是在同一缓存行中），当必须共享值时使用指针。



## 逃逸分析


