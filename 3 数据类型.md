


1. [20: 不了解切片的长度和容量](#20-不了解切片的长度和容量)
2. [22：对 nil 和空切片的困惑](#22对-nil-和空切片的困惑)
3. [24: 无法正确复制切片](#24-无法正确复制切片)
4. [26：切片和内存泄露](#26切片和内存泄露)
	1. [容量的泄露](#容量的泄露)
	2. [切片和指针](#切片和指针)
5. [27：低效的 map 初始化](#27低效的-map-初始化)
6. [28：map 和内存泄露](#28map-和内存泄露)


总结：

- 在Go中整数上溢和下溢是被静默处理的，可实现自己的函数捕获
- 切片的长度是切片中可用元素的数量，而切片容量是底层数组中元素的数量
- 创建切片时，如果已知其长度，请使用给的的长度或容量对其进行初始化。这可减少资源分配的数量并可提高性能。同样的逻辑也适用于 map
- 如果两个不同的函数使用的切片共用同一个底层数组，则使用复制或完整切片表达式可以防止 append 时产生冲突。然而，如果你想缩小一个大的切片，只有使用切片复制可以防止内存泄露。
- 要使用 copy 内置函数将一个切片复制到另一个切片，复制的元素数取决于两个切片长度之间的最小值。
- 使用带有指针字段的指针切片或结构体，可以通过将切割操作排除的元素标记为 nil 来避免内存泄露。
- nil 切片和空切片的区别：nil 切片不需要资源分配
- 要检查切片是否不包含任何元素，请检查其长度。无论切片是nil 还是空，此检查都有效。对于 map 也是如此。
- 要设计明确的 API，不应区分 nil 和空切片
- map 可以在内存中不断增长，但它永远不会缩小


# 20: 不了解切片的长度和容量

在 Go 中，当一个切片包含小于或等于 1024 个元素时，它会每次按一倍的容量增加，当超过 1024 个元素后，会按 25% 的容量增长。


# 22：对 nil 和空切片的困惑

- 如果切片长度等于 0，则切片为空。
- 如果切片等于 nil, 则切片为 nil。


```go
func main() {
	var s []string        // len(s) == 0, s == nil

	s = []string(nil)     // len(s) == 0, s == nil

	s = []string{}        // len(s) == 0, s != nil

	s = make([]string, 0) // len(s) == 0, s != nil
}
```

- 初始化 nil 切片不需要任何资源分配，而空切片需要。

- 优先使用 nil 切片 `var s []string `



# 24: 无法正确复制切片

- 复制到目标的元素数量 = min(源切片长度，目标切片长度)
- 如果要执行完整的复制，目标切片的长度必须大于等于源切片的长度

```go
func correct() {
	src := []int{0, 1, 2}
	dst := make([]int, len(src))
	copy(dst, src)
	fmt.Println("dst = ",dst)   // dst = [0 1 2]
}
```

# 26：切片和内存泄露

在现有的情况下对现有切片或数组进行切割操作可能会导致内存泄露。

- 容量的泄露
- 切片和指针

## 容量的泄露

消息包含 100 万字节，前 5 字节表示消息类型。
使用 msg[:5] 对 msg 进行切割操作会创建一个长度为 5 的切片。
但它的容量仍然与初始切片相同。剩余的元素仍然分配在内存中，即使最终没有引用 msg。

msg[:5]切割完成后，切片底层数组仍包含 100 万字节。（如果在内存中保存1000条消息，内存消耗大约 1GB，而不是5KB）

*可以使用 copy 制作切片副本，而不是对 msg 进行切割：*

```go
func getMessageTypeWithCopy(msg []byte) []byte {
	msgType := make([]byte, 5)
	copy(msgType, msg)
	return msgType
}
```

- 经验法则：切割一个大的切片或数组可能会导致潜在的高内存消耗。剩余的空间不会被 GC 回收，尽管只使用了几个元素，我们仍然需要保留一个大的底层数组。使用切片副本可防止容量泄露。

## 切片和指针

- 如果元素是指针或具有指针字段的结构体(切片），则元素不会被 GC 回收。


如何确保不泄露剩余 Foo 元素？
  1. 创建切片副本可确保不泄露切片剩余元素
  2. 将切片的剩余元素显式标记为 nil


```go
package main

import (
	"fmt"
    "runtime"
)

type Foo struct {
	v []byte
}

func main() {
	foos := make([]Foo, 1_000)
	printAlloc() // 128 KB

	for i := 0; i < len(foos); i++ { // 为每个元素分配 1 MB 字节
		foos[i] = Foo{
			v: make([]byte, 1024*1024),
		}
	}
	printAlloc() // 1024141 KB

	two := keepFirstTwoElementsOnly(foos)
	runtime.GC() // 运行GC以强制清理堆
	printAlloc() // 1024141 KB
	runtime.KeepAlive(two)
}

// 泄露切片剩余元素
func keepFirstTwoElementsOnly(foos []Foo) []Foo {
	return foos[:2]
}



// 如何确保不泄露剩余 Foo 元素？

// 1. 创建切片副本可确保不泄露切片剩余元素
func keepFirstTwoElementsOnlyCopy(foos []Foo) []Foo {
	res := make([]Foo, 2)
	copy(res, foos)
	return res
}

// 2. 如果想保持 1000 个元素的容量，那就将切片的剩余元素显式标记为 nil
func keepFirstTwoElementsOnlyMarkNil(foos []Foo) []Foo {
	for i := 2; i < len(foos); i++ {
		foos[i].v = nil
	}
	return foos[:2]
}

func printAlloc() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	fmt.Printf("%d KB\n", m.Alloc/1024)
}
```


# 27：低效的 map 初始化

在 Go 中， map 基于哈希表数据结构。在内部，哈希表是一个桶的数据结构，每个桶都是一个指向键值对数组的指针。

哈希表中，底层是由4个元素组成的数组，查看数组索引，一个桶包含一个键值对元素，每个桶有固定大小的8个元素。

*map 增长的条件是什么？*

- 桶中的平均条目数量大于一个常量，负载系数大于6.5
- 溢出桶太多（包含8个以上的元素）



```go
m := make(map[string]int, 1_000_000) // 初始化包含100万个元素的 map 
```

初始化时指定了大小，大约快 60%，通过提供大小数值，我们可以在插入元素时防止 map 增长。

如果预先知道 map 将包含的元素数量，那我们应该创建它时提供它的初始大小。这样做可以避免潜在的 map 增长带来的大量计算，因为这需要重新分配足够的空间并重新平衡所有元素。

# 28：map 和内存泄露

```go
m := make(map[int][128]byte)
```

0 MB    // 分配 m 后
317 MB  // 添加 100 万个元素后
288 MB  // 删除 100 万个元素后

从 map 中删除元素不会影响现有存储桶的数量；它只是将桶中的位置设置了零值。一个 map 只能增长并拥有更多的桶；它从不缩小。

内存从 317 MB 降到了 293 MB, 是因为元素被回收了，但运行 GC 不会影响 map 本身。

如果不想手动重新启动服务来清理 map 所消耗的内存量，有什么解决方案吗？
- 重新创建一个当前 map 的副本。

例如：每一小时，我们构建一个新的 map,复制所有元素，然后释放掉上一个。缺点：在复制之后，直到下一次垃圾收集之前，可能会在这段时间消耗双份的内存。

- 更改 map 类型，改成存储数组指针：`map[int]*[128]byte`


<table>
    <thead>
        <tr>
            <th>步骤</th>
            <th>make(map[int][128]byte)</th>
            <th>make(map[int]*[128]byte)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>分配 m 后 </td>
            <td> 0 MB </td>
            <td>0 MB</td>
        </tr>
        <tr>
            <td>添加 100 万个元素后</td>
            <td>317 MB</td>
            <td>170 MB</td>
        </tr>
        <tr>
            <td>删除 100 万个元素</td>
            <td>288 MB</td>
            <td>36 MB</td>
        </tr>
    </tbody>
</table>



删除所有元素后，`map[int]*[128]byte` 类型所需的内存量明显减少

- 向一个 map 添加 n 个元素，然后再删除它们，意味着在内存中将依然会保留着这些桶。
  必须记住，因为在 Go 中 map 的大小只能增加，所以它占用的内存也会增加。目前没有自动化的策略来缩小它。

- 如果这导致高内存消耗，可以强制Go 重建 map 或者使用指针,重新创建一个当前 map 的副本，或更改 map 类型，改成存储数组指针：`map[int]*[128]byte`


