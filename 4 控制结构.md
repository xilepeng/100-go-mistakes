
1. [#go 1.22 后，for 循环里的 i 的地址是变化的](#go-122-后for-循环里的-i-的地址是变化的)
2. [#30：忽略 range 循环中元素被复制的事实](#30忽略-range-循环中元素被复制的事实)
3. [#31：忽略 range 循环中参数是如何求值的](#31忽略-range-循环中参数是如何求值的)
4. [#32: 忽略在 range 循环中使用指针元素的影响](#32-忽略在-range-循环中使用指针元素的影响)
5. [#34:  忽略 break 语句是如何工作的](#34--忽略-break-语句是如何工作的)
6. [#35: 在循环中使用 defer](#35-在循环中使用-defer)


- range 循环中的值元素时一个拷贝。因此，如果想更新一个结构体，应通过索引或传统的 for 循环
- 提供给 range 操作符的表达式只在循环前执行一次
- 使用局部变量或使用索引访问元素，可以避免在循环中复制指针
- 循环中使用 switch 或 select 语句，推荐使用带标签的 break 或 continue 强制退出指定语句
- 将循环内的逻辑提取到函数中进行调用，将会在每次迭代结束时执行函数里的 defer 语句

# #go 1.22 后，for 循环里的 i 的地址是变化的

```go

func listing0() {
	for i := 0; i < 3; i++ {
		fmt.Printf("&i=%p\n", &i)
	}
}

// go 1.22 后，i 的地址是变化的
// i0 i1 i2,超出作用域自动回收
//&i=0x14000182020
//&i=0x14000182040
//&i=0x14000182048

func listing1() {
	s := []int{0, 1, 2}
	for i, val_copy := range s {
		fmt.Printf("i=%p,val_copy=%p\n", &i, &val_copy)
	}
	fmt.Println("原始切片 s =", s) //  s= [0 1 2]
}

//i=0x1400010a028,val_copy=0x1400010a020
//i=0x1400010a058,val_copy=0x1400010a050
//i=0x1400010a068,val_copy=0x1400010a060

func listing2() {
	s := []int{1, 2, 3}
	for index := range s {
		fmt.Printf("index=%d ", index)
	}
}

//index=0 index=1 index=2
```

# #30：忽略 range 循环中元素被复制的事实

在 range 循环中，值元素是一个拷贝

```go
func value_copy() {
	s := []int{0, 1, 2}
	for _, s_copy := range s {
		s_copy += 10
	}
	fmt.Println("原始切片 s =", s) //  s= [0 1 2]
}

func update_slice() {
	s := []int{0, 1, 2}
	for i := range s {
		s[i] += 10
	}
	fmt.Println("使用索引变量访问切片中的元素 s =", s) // s = [10 11 12]

	for i := 0; i < len(s); i++ {
		s[i] += 10
	}
	fmt.Println("使用传统for访问切片 s =", s) // s = [20 21 22]
}

type accounts struct {
	balance float32
}

func pointer_slice() {
	a := []*accounts{{balance: 0}, {balance: 1}, {balance: 2}}
	for _, a := range a {
		a.balance += 10
		fmt.Println("更新后的切片元素 a.balance =", a.balance)
	}
}
//更新后的切片 a.balance = 10
//更新后的切片 a.balance = 11
//更新后的切片 a.balance = 12

func main() {
	value_copy()
	update_slice()
	pointer_slice()
}

/*
原始切片 s = [0 1 2]
使用索引变量访问切片中的元素 s = [10 11 12]
使用传统for访问切片 s = [20 21 22]
更新后的切片 a.balance = 10
更新后的切片 a.balance = 11
更新后的切片 a.balance = 12
*/

```






# #31：忽略 range 循环中参数是如何求值的

当使用 range 循环时，只在开始循环前对提供的表达式求值一次，这里“求值”的含义是将表达式复制到一个临时变量，然后 range 循环迭代这个临时变量

for 循环执行 len(s1) = 3 次后终止

```go
	s1 := []int{0, 1, 2}
	for range s1 {
		s1 = append(s1, 10)
	}
	fmt.Println("s1=", s1) // s1 = [0 1 2 10 10 10]
```


由于 range 表达式是在循环开始前求值的，所以赋值到循环零时变量的是这个数组的拷贝。

```go
func no_update_copy() {
	a := [3]int{0, 0, 0}
	a_copy := []int{}
	for i, v := range a {
		a[i] = 1
		a_copy = append(a_copy, v)
	}
	fmt.Println("a_copy =", a_copy) // a_copy = [0 0 0]
	fmt.Println("a =", a)           // a = [1 1 1]
}
```


```go
func listing1() {
	a := [3]int{0, 1, 2}
	for i, v := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println("打印数组拷贝，循环不会更新数组拷贝", v) // 2
		}
	}
}
```

<table>
    <thead>
        <tr>
            <th>迭代开始前</th>
            <th>数组拷贝 = [0,1,2]</th>
            <th>a = [0,1,2]</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>第一次迭代后</td>
            <td>[0,1,2] ->0</td>
            <td>[0,1,10]</td>
        </tr>
        <tr>
            <td>第二次迭代后</td>
            <td>[0,1,2] ->1</td>
            <td>[0,1,10]</td>
        </tr>
        <tr>
            <td>第三次迭代后</td>
            <td>[0,1,2] ->2</td>
            <td>[0,1,10]</td>
        </tr>
    </tbody>
</table>

range 迭代数组拷贝（左侧）、同时循环体更新a （右侧）

- range 运算符创建数组的拷贝，循环不会更新这个拷贝，它更新原始数组a 


如果想打印最后一个元素的实际值，可通过以下两种方式：

```go
func listing2() {
	a := [3]int{0, 1, 2}
	for i := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println("使用索引访问原始数组", a[2]) // 10
		}
	}
}

func listing3() {
	a := [3]int{0, 1, 2}
	for i, v := range &a {
		a[2] = 10
		if i == 2 {
			fmt.Println("使用数组指针访问原始数组", v) // 10
		}
	}
}
```

# #32: 忽略在 range 循环中使用指针元素的影响

- 使用局部变量或使用索引访问元素，可以避免在循环中复制指针

当使用 range 循环迭代一个数据结构时，所有的值都被赋给一个具有唯一地址的唯一变量。




# #34:  忽略 break 语句是如何工作的

break 语句终止最里面的 for 、switch 、select 语句，跳出外循环常用标签


```go
func listing1() {
	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", i)

		switch i {
		default:
		case 2:
			break // 中断 switch 语句
		}
	}
}

func listing2() {
loop:
	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", i)

		switch i {
		default:
		case 2:
			// 等价于 return
			break loop // Breaks out of the outer loop
		}
	}
}

func listing3(ctx context.Context, ch <-chan int) {
	for {
		select {
		case <-ch:
			// Do something
		case <-ctx.Done():
			break
		}
	}
}

func listing4(ctx context.Context, ch <-chan int) {
loop:
	for {
		select {
		case <-ch:
			// Do something
		case <-ctx.Done():
			break loop// 终止 loop 标签关联循环，而不是 select
		}
	}
}

```

也可以使用带标签的 continue 跳到带标签的循环的下一次迭代


# #35: 在循环中使用 defer

- 将循环内的逻辑提取到函数中进行调用，将会在每次迭代结束时执行函数里的 defer 语句
- 使读文件函数成为一个闭包

```go
func readFiles1(ch <-chan string) error {
	for path := range ch {
		file, err := os.Open(path)
		if err != nil {
			return err
		}

		defer file.Close()

		// Do something with file
	}
	return nil
}

func readFiles2(ch <-chan string) error {
	for path := range ch {
		if err := readFile(path); err != nil {
			return err
		}
	}
	return nil
}

func readFile(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}

	defer file.Close()

	// Do something with file
	return nil
}

func readFiles3(ch <-chan string) error {
	for path := range ch {
		// 使读文件函数成为一个闭包
		err := func() error {
			file, err := os.Open(path)
			if err != nil {
				return err
			}

			defer file.Close()

			// Do something with file
			return nil
		}()
		if err != nil {
			return err
		}
	}
	return nil
}
```

