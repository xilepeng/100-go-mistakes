
1. [30：忽略 range 循环中元素被复制的事实](#30忽略-range-循环中元素被复制的事实)
2. [31：忽略 range 循环中参数是如何求值的](#31忽略-range-循环中参数是如何求值的)
3. [34:  忽略 break 语句是如何工作的](#34--忽略-break-语句是如何工作的)
4. [35: 在循环中使用 defer](#35-在循环中使用-defer)


# 30：忽略 range 循环中元素被复制的事实

在 range 循环中，值元素是一个拷贝



```go
func value_copy() {
	s := []int{0, 1, 2}
	for _, s_copy := range s {
		s_copy += 10
	}
	fmt.Println("原始切片 s =", s) //  s= [0 1 2]
}

func update_slice() {
	s := []int{0, 1, 2}
	for i := range s {
		s[i] += 10
	}
	fmt.Println("使用索引变量访问切片中的元素 s =", s) // s = [10 11 12]

	for i := 0; i < len(s); i++ {
		s[i] += 10
	}
	fmt.Println("使用传统for访问切片 s =", s) // s = [20 21 22]
}

type accounts struct {
	balance float32
}

func pointer_slice() {
	a := []*accounts{{balance: 0}, {balance: 1}, {balance: 2}}
	for _, a := range a {
		a.balance += 10
		fmt.Println("更新后的切片元素 a.balance =", a.balance)
	}
}

func main() {
	value_copy()
	update_slice()
	pointer_slice()
}

/*
原始切片 s = [0 1 2]
使用索引变量访问切片中的元素 s = [10 11 12]
使用传统for访问切片 s = [20 21 22]
更新后的切片 a.balance = 10
更新后的切片 a.balance = 11
更新后的切片 a.balance = 12
*/

```


# 31：忽略 range 循环中参数是如何求值的

当使用 range 循环时，只在开始循环前对提供的表达式求值一次，这里“求值”的含义是将表达式复制到一个临时变量，然后 range 循环迭代这个临时变量

for 循环执行 len(s1) = 3 次后终止

```go
	s1 := []int{0, 1, 2}
	for range s1 {
		s1 = append(s1, 10)
	}
	fmt.Println("s1=", s1) // s1 = [0 1 2 10 10 10]
```


由于 range 表达式是在循环开始前求值的，所以赋值到循环零时变量的是这个数组的拷贝。

```go
func no_update_copy() {
	a := [3]int{0, 0, 0}
	a_copy := []int{}
	for i, v := range a {
		a[i] = 1
		a_copy = append(a_copy, v)
	}
	fmt.Println("a_copy =", a_copy) // a_copy = [0 0 0]
	fmt.Println("a =", a)           // a = [1 1 1]
}
```


```go
func listing1() {
	a := [3]int{0, 1, 2}
	for i, v := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println("打印数组拷贝，循环不会更新数组拷贝", v) // 2
		}
	}
}
```

<table>
    <thead>
        <tr>
            <th>迭代开始前</th>
            <th>数组拷贝 = [0,1,2]</th>
            <th>a = [0,1,2]</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>第一次迭代后</td>
            <td>[0,1,2] ->0</td>
            <td>[0,1,10]</td>
        </tr>
        <tr>
            <td>第二次迭代后</td>
            <td>[0,1,2] ->1</td>
            <td>[0,1,10]</td>
        </tr>
        <tr>
            <td>第三次迭代后</td>
            <td>[0,1,2] ->2</td>
            <td>[0,1,10]</td>
        </tr>
    </tbody>
</table>

range 迭代数组拷贝（左侧）、同时循环体更新a （右侧）

- range 运算符创建数组的拷贝，循环不会更新这个拷贝，它更新原始数组a 


如果想打印最后一个元素的实际值，可通过以下两种方式：

```go
func listing2() {
	a := [3]int{0, 1, 2}
	for i := range a {
		a[2] = 10
		if i == 2 {
			fmt.Println("使用索引访问原始数组", a[2]) // 10
		}
	}
}

func listing3() {
	a := [3]int{0, 1, 2}
	for i, v := range &a {
		a[2] = 10
		if i == 2 {
			fmt.Println("使用数组指针访问原始数组", v) // 10
		}
	}
}
```



# 34:  忽略 break 语句是如何工作的

break 语句终止最里面的 for 、switch 、select 语句，跳出外循环常用标签


``` go
func listing1() {
	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", i)

		switch i {
		default:
		case 2:
			break // 中断 switch 语句
		}
	}
}

func listing2() {
loop:
	for i := 0; i < 5; i++ {
		fmt.Printf("%d ", i)

		switch i {
		default:
		case 2:
			// 等价于 return
			break loop // Breaks out of the outer loop
		}
	}
}

func listing3(ctx context.Context, ch <-chan int) {
	for {
		select {
		case <-ch:
			// Do something
		case <-ctx.Done():
			break
		}
	}
}

func listing4(ctx context.Context, ch <-chan int) {
loop:
	for {
		select {
		case <-ch:
			// Do something
		case <-ctx.Done():
			break loop// 终止 loop 标签关联循环，而不是 select
		}
	}
}

```

也可以使用带标签的 continue 跳到带标签的循环的下一次迭代


# 35: 在循环中使用 defer

```go
func readFiles1(ch <-chan string) error {
	for path := range ch {
		file, err := os.Open(path)
		if err != nil {
			return err
		}

		defer file.Close()

		// Do something with file
	}
	return nil
}

func readFiles2(ch <-chan string) error {
	for path := range ch {
		if err := readFile(path); err != nil {
			return err
		}
	}
	return nil
}

func readFile(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}

	defer file.Close()

	// Do something with file
	return nil
}

func readFiles3(ch <-chan string) error {
	for path := range ch {
		err := func() error {
			file, err := os.Open(path)
			if err != nil {
				return err
			}

			defer file.Close()

			// Do something with file
			return nil
		}()
		if err != nil {
			return err
		}
	}
	return nil
}
```